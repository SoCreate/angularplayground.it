<h1>Sandbox API</h1>
<section markdown>
  All of the sandbox API functions/classes/interfaces are exported from the `angular-playground`
  module to enable easy access for TypeScript clients.
</section>
<h5>Function</h5>
<div markdown path="content/docs/api/api.md"></div>
<section markdown>
  The `sandboxOf` function returns an instance of a `SandboxBuilder` that has a fluent
  api allowing for method chaining via it's `add` method. The `add` method is used to add
  scenarios for your sandboxed component. Each scenario needs a `description` (the first parameter),
  and a `scenarioConfig` object (the second parameter). The `scenarioConfig` object requires a
  `template` property at a minimum.
</section>
<h5>Class</h5>
<div markdown path="content/docs/api/api2.md"></div>
<h5>Interfaces</h5>
<div markdown path="content/docs/api/api3.md"></div>
<section markdown>
  The `SandboxOfConfig` gives you a way to set dependencies for the sandboxed component. This creates
  a dynamic `NgModule` around the sandboxed component. So these config properties are the same ones you
  are used to using for an `NgModule` decorator.
</section>
<section markdown>
  The `entryComponents` property is used to define components that are not found in template markup
  and created dynamically (i.e.: overlays, panels, modals).

  The `schemas` property defines schemas for use in sandboxes, such as:
  <ul>
    <li>`NO_ERRORS_SCHEMA` - allow any
      property on any element</li>
    <li>`CUSTOM_ELEMENTS_SCHEMA` - allow NgModule to contain non-Angular elements or
      element properties named with dash case (-)</li>
  </ul>

  The `label` property allows you to label your sandboxes. This value gets rendered next to the
  component name in the Playground UI. So if you have 2 components in your app named `InfoBlock` that lived
  in different features, you could use the `label` to make those unique for readability in the UI (something
  like `label: 'featureA.'` and `label: 'featureB.'`).

  The `declareComponent` is optional and gets set to `true` by default. Components that get sandboxed
  will get declared in a host `NgModule` when dynamically rendered. If you want to import in an `NgModule`
  that contains the component that you are sandboxing then you can set `declareComponent` to `false`.
</section>
<div markdown path="content/docs/api/api4.md"></div>
<section markdown>
  The `ScenarioConfig` gives you a way to set dependencies at the component level. These are used as the
  `Component` decorator metadata for a host component that renders your sandboxed component as well as the
  host component context (i.e. - any type of class properties on the host component that you want to be able
  to feed to your sandboxed component). So these config properties are the same ones you are used to using for
  a parent component.
</section>
