<h1>Setup without Angular CLI</h1>
<section markdown>
  Playground is designed to use your existing app as a host for
  serving up a Playground application, which is nothing more
  than an Angular entry module that can be bootstrapped.

  Setting up an existing application without Angular CLI requires a few steps:

  1. Create an entry point for Playground: `main.playground.ts`
  2. Configure a new `angular-playground.json` file
  3. Update tsconfig compiler options (`tsconfig.json`)
  4. Set up a resolve alias in your Webpack settings (`webpack.config.js`)
  5. Add a scripts entry to `package.json`
</section>
<h4>Install Angular Playground</h4>
<section markdown>
  ```
  npm install --save-dev angular-playground
  ```
</section>
<h4>A New Main Entry File</h4>
<section markdown path="content/docs/getting-started/bootstrapping.md"></section>
<section markdown>
  You can use your existing `index.html` and whatever other build/serve scenario you
  have in place for you app, you just need to change your entry point to be this
  `main.playground.ts` file instead of your `main.ts` file, or you could do some other
  type of logic to run the `initializePlayground` and bootstrap the `PlaygroundModule` conditionally.

  ##### Entry HTML Page

  The `initializePlayground` function takes in an element selector string. The element
  selector is used to find your existing app element in your `index.html` DOM and
  replace it with the element selector used by the Playground `AppComponent`.

  If you decide to set up a separate `index.html` file in your project for Playground
  you would still need to call `initializePlayground()`, just with no
  argument for the element selector. Instead, you can manually add the `ap-root` element in your
  `index.html` file.
</section>
<h4>Add the Angular Playground Config</h4>
<div markdown path="content/docs/getting-started/non-angular-cli.md"></div>
<section markdown>
  The above configuration file is used to configure many different Playground options (including running
  tests, integration with @angular/cli, etc.). See the <a routerLink="/docs/api/configuration">API documentation</a>
  for more information.
</section>
<h4>Update tsconfig Compiler Options</h4>
<section markdown>
  Change the `compilerOptions.module` option in your `tsconfig.json` to <em>"esnext"</em>.
</section>
<div markdown path="content/docs/getting-started/angular-cli6.md"></div>
<h4>Resolving the sandboxes.ts File</h4>
<section markdown>
  The `PlaygroundModule` will load the sandboxes.ts file that the CLI generates via a `require('sandboxes')` call.
  For that to work you need to support module resolution of that **sandboxes** path to the sandboxes.ts
  file.

  If you are using Webpack, this can be accomplished with a `resolve.alias`:
</section>
<section markdown path="content/docs/bootstrapping/webpack.md"></section>
<section markdown>
  [Here's an example webpack configuration.](https://github.com/SoCreate/angular-playground/tree/master/examples/example-app-webpack/config)
</section>
<h4>Add Playground to Package.json</h4>
<div markdown path="content/docs/getting-started/angular-cli7.md"></div>
<section markdown>
  Add the entry `"playground": "angular-playground"` to the scripts listing in your `package.json`. 

  ```
  npm run playground
  ```

  To run Playground, you will need to serve your application with your build system of choice while
  running the Playground CLI.

  For example, the two commands below need to be ran simultaneously:

  ```
  npm run playground
  webpack-dev-server --inline --port 8081 --config config/webpack.playground.js
  ```
</section>
<h4>Next Steps</h4>
<section markdown>
  * <a routerLink="/docs/how-to/sandboxing-components">Start sandboxing components</a>
  * <a routerLink="/docs/how-to/keyboard-shortcuts">Learn how to navigate Playground</a>
  * [Check out a working example](https://github.com/DanWahlin/Angular-JumpStart)
</section>
